---
title: "R Language Basics"
---

## Overview

R is a programming language and software environment based on another programming language called S.
It is primarily used for data management, analysis, and presentation. 
R is free to use and open-source, making it both approachable to new learners and flexible for advanced users. 
R is built on collaboration and transparency, with a large community contributing to the development of the language and tools extending its functionality.
The R community also works to make R accessible and functional, with extensive documentation for the language itself and its packages of functions.
Beyond documentation, you can find a wealth of user-created resources for learning and using R, including freely available tutorials, videos, workshops, and full courses and textbooks (ahem).

#### R vs. Python

Both R and Python are popular choices for statistical analysis and visualization in research, and the two have a lot in common.
They are both free, open-source languages with large communities and extensive libraries of functions. 
The biggest difference between the two is that R is primarily focused on statistical analysis and visualization, while Python is a general-purpose programming language that can be used for data analysis as well as a range of other applications.

If Python can do so much more than R, why would anyone use R? Because the Python's versatility is a little bit of a double edged sword.
Of course Python can handle complex data analysis like R, but R is *designed* for this stuff.
Because R is highly specialized, a little code and knowledge go a long way.
You do the work of knowing what kinds of data problems you need to solve, and R and the R community will give you powerful and precise tools to solve them.^[Absolutely no shade on Python here. Yay Python! A+ great job! But this is a class about R.]

Although Python is more widely used generally, R tends to be favored in academic and research settings, especially in the social sciences.
As a psychologist, I care about managing data in reproducible and transparent ways, conducting and reporting a range of statistical analyses, and creating high-quality, publication-ready visualizations.
R lets me get straight to the point to do all that, and it lets me do it without having to learn a language enough to really call myself a "programmer."

#### RStudio

We talked about RStudio in @sec-rstudio, but in case you missed it, here's some things to know as you get started with R.

R is a programming language; RStudio is an integrated development environment (IDE) for that language. You interact with R via the RStudio software. R exists without RStudio, but not the other way around.

Well, at least in theory. In practice, RStudio is *the* way to interact with R. It's a (relatively) user-friendly interface for writing and executing R code that is pretty streamlined to the needs of the R user. 
Unlike other popular IDEs (e.g., Visual Studio, AWS, Eclipse), RStudio doesn't need to meet the needs of *any* programmer who might be doing *anything* in *any* language.
Consequently, RStudio is the go-to for R users, since it lacks the clutter that comes with general-purpose IDEs.

What you need to know now is:

1. R =/= RStudio...
2. ...but it kinda might as well.

#### Object-oriented programming

R is an *object-oriented programming language*, which means that it is built around the concept of "objects" that contain data and functions.
What's an object? 
According to [Wikipedia](https://en.wikipedia.org/wiki/Object_(computer_science)), an *object* is "an entity that has state, behavior, and identity."
I personally find that definition to be baffling, because like...isn't that anything?

Well, it kind of *is* anything. You can think of objects in R as any *thing* you want to work with in R.
If it's something you'd want to put a label on for some reason, that's an object.
A number or string as a variable to use later? Object.
A table with data? Object.
The output of a statistical test? Object.
A plot? Object.

You get the idea. 
Basically, every time you open up a new R session, you are the god of a tiny little empty world. 
If you want to see something happen in your world, you have to create the stuff that does the happening and is happened to and is the happening.^[I study language. I'm allowed to talk nonsense like this.]
Want to watch the denizens of your universe put on a play about a magician who eats too much cheese?
You have to bring into existence the players, the script, and the stage, but also the concepts of "play," "magician," "cheese," "eating", and "the amount that is socially and/or biologically too much cheese."

In R, if you want to see a graph of the relationship between how much cheese an individual eats and whether or not they are a magician, you have to create that world with objects -- the *environment*. 
The variables "how much cheese" and "is magician?" are objects. The rows, columns, and values that make up a table of data are objects. Those objects are all inside of an object that is the table itself. The calculation of the association between the two variables is an object. The graph that visualizes the relationship is an object. The axis labels on the plot object are objects...

What you need to know: 

1. R works by doing stuff to stuff. 
2. So "stuff" has to exist.

## R syntax

In natural language, syntax is the system of rules that govern how words are combined to form phrases and sentences in meaningful ways. Sentence makes mixing nothing all words of at the a it something up else or mean.^[Mixing up the words of a sentence makes it mean something else or nothing at all.] 

<!-- Men in tights clip of sheriff of rottingham -->
{{< video https://www.youtube.com/embed/CKhGiFOMsS0 >}}

Some things are nouns, some are verbs. Some verbs need objects, some don't. Some words mean more than one thing and require specification or context. Some words connect other words together. Some words don't serve a lot of functional purpose but make the sentence sound better or easier to understand. Words like pronouns can replace other words, but only after following the rules to let you do that. Some words you can omit entirely by restructuring other parts of the sentence. Some rules will technically communicate a meaning correctly, but are much more understandable if there is non-speech stuff like gestures or facial expressions to help clarify the meaning. Some rules are more flexible than others, and some are more rigid. Some rules are more important than others, and some are more about style than substance.

In a programming language, syntax works similarly. R syntax is the set of rules that govern how you write code in R to make it do what you want it to do.
For each example I gave for natural language above, I can think of at least one equivalent situation. Adding in stuff that isn't necessary to make it easier to read? That's taking advantage of R being whitespace insensitive. Using gesture to complement ambiguous meaning? That's using comments. Eliding a subject because it's implicit or otherwise already understood? That's skipping optional arguments in functions, or using the pipe operator to pass objects from arguments in one function to arguments in another. You get the picture.

While programming languages are nowhere near as complex and dynamic as natural languages, you can think about programming syntax as using the same kinds of building blocks.

### Environments

Your R *environment* is the collection of objects that exist in your R session at any given time. 
When you start a new R session, your environment is empty.
Creating variables, data structures, functions, plots, and other objects adds them to your environment so you can refer to them later.

Everything in your environment has a unique identifier, the name you give the object.
Because identifiers are unique, creating an object with the same name as an existing object will overwrite the existing object with the new one.

You can see the objects in your environment by looking at the Environment pane in RStudio, or by using the `ls()` function in the R console to list the objects in your environment.
Critically, you can only interact with objects that exist in your environment, and environments are not persistent across R sessions.
When you close RStudio, your environment is cleared, and you have to recreate any objects you want to use in the next session.


### Variables

Variables are the nouns of R syntax. These objects are the "things" you create, look at, manipulate, etc. 

In R we create variables by assigning a value to a name with the assignment operator `<-`. Technically you can use `=` to assign a value to a variable, but you really shouldn't; `<-` is the preferred assignment operator in R. <!-- link to something explaining why -->

Once you have created a variable, you can use it in your code to refer to the value it contains, including assigning other variables.

For example:

```r
the_answer <- 42
pi <- 3.14159
round_answer <- pi*the_answer

my_name <- "Natalie"
your_name <- "Lucas"
our_names <- c(my_name, your_name)
```

You can even assign values to variables using the existing variable itself:

```r
last_name <- "Dowling"
my_name <- paste(my_name, last_name)
```

### Functions

### Data types

Any piece of data you can work with in R takes one of 6 forms: numeric, integer, complex, character, factor^["Factor" is technically not a data type, but we can treat it like one.], and logical.
The first three are number-y, the next two are word-y, and the last is truth-y.

We'll break down 5 of these 6 (we'll skip complex, but you can learn more about them [here](https://www.r-bloggers.com/2009/12/using-complex-numbers-in-r/) if you like). For quick reference:

| Data type | Description | Example |
|-----------|-------------|---------|
| Numeric   | Decimal numbers, including whole numbers | `3.14`, `42.0`, `-1.5` |
| Integer   | Whole numbers, represented with an `L` suffix | `42L`, `-1L`, `1000L` |
| Complex   | Numbers with a real and imaginary part, represented with a `i` suffix | `3 + 4i`, `2 - 5i` |
| Character | Text strings, enclosed in quotes | `"hello"`, `'123'`, `"R is great!"` |
| Factor    | Leveled categorical data, stored as integers with labels | `factor(c("low", "medium", "high"))` | 
| Logical   | Boolean values, either `TRUE` or `FALSE` | `TRUE`, `FALSE`, `x > 5` |

You can check the data type of an object using the `class()` function, which will return the class of the object. 
Try using `class()` on the examples above to see what it returns, like:

```r
class(3.14)          # "numeric"
class(42L)           # "integer"
class("hello")       # "character"
class(factor(c("low", "medium", "high")))  # "factor"
class(TRUE)          # "logical"
```

When you run `class()` and it returns something, it's creating a data object which has to have a type itself. 
See if you can figure out what kind of data is being returned with `class()` by using `class()`^[If you run `class(class(3.14))`, it will return `"character"`.]

#### Numeric

*Numeric* variables are, unsurprisingly, numbers. 
Basically any number that you can treat like a number.
If you added 0 to it, would it equal itself? If so, it's numeric. (As opposed to a string that looks like a number, like `"100"`. Can't add 0 to that, and if you did, it would probably be something like concatenation: `"1000"`.)

Create a numeric variable by assigning a number made up of digits, decimals, and/or negative signs to a variable name:

```r
my_number <- 3.14
my_other_number <- -42
```

#### Integer

The *integer* variable is a subset of numeric variables.
A number that does not have a decimal point is an integer.
Integers are whole numbers (1, 5, 100000), negative whole numbers (-1, -5, -100000), and zero (0).

Pick your favorite number without a decimal point, and assign it to a variable name, then run `class()` on that variable to see its data type:

```r
lucky <- 11
class(lucky)  # ???integer???
```

Running class on something that looks like an integer will return numeric, not integer.
Remember that integers are a subset of numeric variables, so R is taking a better-safe-than-sorry approach and assuming you want the more generic, broad-scope version of what you gave it.

If you want to specify a variable as an integer, you can do so by adding an `L` suffix to the number when you assign it to a variable:

```r
luckier <- 11L
class(luckier)  # "integer"!
```

You can also convert an existing numeric value to an integer with `as.integer()`:

```r
my_number <- 42
class(my_number)  # "numeric"
my_integer <- as.integer(my_number)
class(my_integer)  # "integer"
```

You can use `as.integer()` on non-integer numeric values. The result will be everything before the decimal point, effectively rounding down to the nearest whole number:

```r
my_decimal <- 4.2 # numeric type
another_integer <- as.integer(my_decimal) # 4 - integer type
```

Specifying data as integer with `L` or converting it with `as.integer()` typically isn't necessary, but it can be useful when you need to ensure that a value is treated as an integer, like as an argument of a function that only accepts integers.

The flip of the integer is a *double* variable, which is the default numeric type in R. 
It just means the number can have a decimal point, whether or not it's visually represented. 
Since numeric values are double by default, you won't see `class()` return "double", you just mentally note that that's what you've got.

#### Character



#### Factor



#### Logical



#### Missing data: NA


### Operators

## R data structures

### Vectors

### Lists

### Matrices

### Data frames

### Tibbles


<!-- Citations to add -->
<!-- white_2009_using -->
